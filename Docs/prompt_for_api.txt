I need to create a new end-point to my Google Cloud Functions based Cnidaria-API. Here are the details:

**Project Context:**
- API: Google Cloud Functions (Node.js 20)
- Database: Firebase Firestore
- Framework: Express-style with CORS enabled
- Current base URL: https://us-central1-zone-eaters.cloudfunctions.net/cnidaria-api



**Endpoint 1: /api/curves**
- **HTTP Method:** POST
- **Purpose:** Create a new curve with all required data
- **Data Structure:** 


-- ** Core Curve Properties: The Basic Properties of the Curve - this organization should be reflected in the structure of the JSON file stored to Firebase. Note this in the code comments and documentation when generated.

-- curve-name	string	Enforce alpha-numeric-lowercase. replace spaces with the "-" symbol. Reject names that are taken. If no value is passed, default to "Curve " + the number of curves in the system, i.e. "Curve 34" on creation

-- curve-description	string 

-- curve-tags	array Enforce alpha-numeric-lowercase. replace spaces with the "-" symbol. Each tag can be 256 chars, each array can contain 128 tags. 

-- curve-width	integer if no value is passed default to 89

-- curve-height	float this is a constant as the curve-height is always 255 (read-only), individual values in curve-data range 0-255 and based on this max value.
 

-- curve-type	string must be either Radial | Cartesian X | Cartesian Y   if no value is given default to Radial. Reject any other options if given.


-- curve-index-scaling	float must be a value between 0 and 1.0 - this will determine how many cells (units of distance) from the center it has to be in order to move to the next index position. For example if my curve-data is 10,20,30,40,50,60,70,80,90,100,110 and my curve-index-scaling value is 1.0 then when I am 3 steps away from center my index value is 2 (we count zero) and the returned value is 30. If the curve-index-scaling value is .10 and I'm 9 unadjusted steps/cells away from center then it returns 20 because it's at an adjusted index position of 2. This allows us to have Zoomed out terrains. Reject any value not between 0 and 1. This happens after any index distortions are applied.


-- ** Curve Data: this is an array of values - the length of which is represented by the curve-width, the value at each position is set by the curve position and is a float value somewhere between 0 and 255. We will loop through the index to pull values relative (MODULUS) to the distance from the center 0,0 in both radial, cartesian-x, and cartesian-y ways. We will also apply distortion to the index value in order to create terrain like looks. This is generated by the curve generator



-- curve-data	array, float  This array can hold a max of 65,536 valued and each value can be a float value between 0 and 255 - DECIMAL(3, 4)



-- ** Curve Generator Values: these values are relevant to the react app Curve Generator tool which we use to build these Curves. Besides being saved to the curve and loaded from the curve when editing, there is no additional processing required.


-- generator-noise-type	string will be used by the react app to store what type of noise was used to generate the curve-data

-- generator-noise-setting	map	can accept one, none, or many key value pairs  (up to 24)to accomodate the various setting options available to each noise option such as a pseudo random seed, frequency etc.


-- generator-top-shelf integer this amount minus 255 is the highest allowable value the curve can generate and output. 

 -- generator-bottom-shelf integer this amount is the lowest allowable value the curve can generate and output. Default to zero if no value is present.


 -- generator-value-fill float reject any value not between 0 and 1. A value of 1 will force the waveforms max and min height to fit the 0-255 window whereas a value of 0 will not impact it at all, Values in-between 0 and 1 are degrees to which this effect is applied. Default to 1 if no value is present.
 
 
 -- generator-value-offset integer reject any value not between -128 and 128. A simple offset applied to the curve to push it up or down on the 0-255 height. Default to 0 if no value is present.
 


-- ** Curve Index Distortion Values: these values are relevant to applying index distortion so we can have less procedural looking output. 


-- index-distortion-distortion_level float refer to " ## 3. Index Distortion" to better understand. Default to 0 (no distortion)
-- index-distortion-frequency float refer to " ## 3. Index Distortion" to better understand. default to 1.0
-- index-distortion-angular float  refer to ""## 2. Angular Distortion" to better understand. Default to 0.0 to apply no distortion.


 
 
 
**Endpoint 2: /api/curves/:id**
- **HTTP Method:** GET, PUT, DELETE
- **Purpose:** Retrieve, update, or delete specific curves
- **Operations:**
  - GET: Retrieve curve by ID or curve-name
  - PUT: Update existing curve
  - DELETE: Remove curve with success message
 

-- delete-curve	delete a curve by name or id with a success message.




Endpoint 3: GET /api/curves
Purpose: List all curves with filtering options
Query Parameters: ?filter=tags&date=2024-01-01&page=1&limit=20
- **Purpose:** List all curves with filtering options
- **Features:**
  - List all curves with name and tags
  - Filterable by modification date and tags
  - Pagination support


--list-curves display a list of all curves in the system - with name and tags. Filterable by modification date and tags.



 
 
**Endpoint 4: /api/curves/:id/process**
- **HTTP Method:** POST
- **Purpose:** Process coordinates and return terrain values
- **Features:**
  - GetCurveIndexValue functionality
  - Background caching of surrounding cells
  - Cache management and statistics
  
- **Structure:

-- GetCurveIndexValue (curve-name, x,y, (optional) x2, y2) - When given the coordinates the value at the current index position in the curve-data is delivered, along with the CoordKey (see the CoordKey.ts script to use), index position for the given coordinates. If a second pair of coordinates is provided return those values for every cell in that grid. Return an error if the curve if not found.  

This should return a JSON compliant value (the curve-data value at the final processed index position) float, the final index position	integer, and the CoordKey value string)




--Internally, before any output is returned the following pipeline is followed.



-- index-distortion-distortion_level float refer to " ## 3. Index Distortion" to better understand
-- index-distortion-frequency float refer to " ## 3. Index Distortion" to better understand
-- index-distortion-angular float  refer to ""## 2. Angular Distortion" to better understand

'
***Mathematical Pipeline with API Field References:***
Angular Distortion:
angle_x = (x / curve_width) * 2π
angle_y = (y / curve_width) * 2π
angular_distortion_x = sin(angle_x * index-distortion-angular) * index-distortion-angular
angular_distortion_y = sin(angle_y * index-distortion-angular) * index-distortion-angular
angular_distorted_x = x + angular_distortion_x
angular_distorted_y = y + angular_distortion_y
index-distortion-angular ← From your API: index-distortion-angular field
Coordinate Distortion:
Index Distortion:
noise_input_x = angular_distorted_x * index-distortion-frequency
noise_input_y = angular_distorted_y * index-distortion-frequency
distortion_offset_x = perlin_noise(noise_input_x) * index-distortion-distortion_level
distortion_offset_y = perlin_noise(noise_input_y) * index-distortion-distortion_level
distorted_x = angular_distorted_x + distortion_offset_x
distorted_y = angular_distorted_y + distortion_offset_y
index-distortion-frequency ← From your API: index-distortion-frequency field
index-distortion-distortion_level ← From your API: index-distortion-distortion_level field
Distance Calculation:
Radial: distance = √(distorted_x² + distorted_y²) ← Uses distorted coordinates
Cartesian X: distance = |distorted_x| ← Uses distorted x coordinate
Cartesian Y: distance = |distorted_y| ← Uses distorted y coordinate
Index Scaling:
adjusted_distance = distance * curve_index_scaling
curve_index_scaling ← From your API: curve-index-scaling field
Final Index Calculation:
final_index = adjusted_distance % curve_width
final_index = max(0, min(final_index, curve_width - 1))
curve_width ← From your API: curve-width field
Return Value:
return curve_data[final_index]
curve_data ← From your API: curve-data array field
API Field Mapping Summary:
curve-index-scaling → Controls terrain zoom level
curve-width → Determines array bounds, modulus calculation, and angular distortion scaling
index-distortion-distortion_level → Controls Perlin noise intensity for coordinate distortion
index-distortion-angular → Controls sine wave modulation for coordinate distortion
curve-data → Source array for final terrain values
index-distortion-frequency → Controls noise frequency for coordinate distortion




When this endpoint is invoked it should as a background process cache the surrounding cells and load from the cache versus re-calculating GetCurveIndexValue.


 
**Endpoint 5: /api/curves/:id/cache**
- **HTTP Method:** GET, DELETE
- **Purpose:** Manage curve-specific cache
- **Operations:**
  - GET: Cache statistics and status
  - DELETE: Clear curve cache
  


If a single coordinate is passed to GetCurveIndexValue then cache the GetCurveIndexValue for the cells in a 100 cell radius from the single coordinate provided.


If two coordinates are provided, constituting a grid, then cache the GetCurveIndexValue for 100 cells outside the grid area. Cache extends 100 cells beyond grid perimeter in all directions

**Additional Cache Requirements:**

**Cache Expiration:**
- All cached coordinate calculations expire after 30 minutes (1800 seconds)
- Cache TTL is automatically managed by the system

**Cache Behavior:**
- GetCurveIndexValue will ALWAYS check cache first
- If cache HIT: Return cached value and reset 30-minute expiration timer
- If cache MISS: Calculate value, cache result with 30-minute TTL, then return
- NO re-processing of GetCurveIndexValue for cached coordinates

**Cache Namespace:**
- Cache is always tied to curve-name as namespace
- Example: "mountain-terrain" coordinates are cached separately from "desert-terrain" coordinates
- No cross-contamination between different curves

**Cache Invalidation:**
- Any changes to the parent curve automatically clear ONLY that curve's cache
- Other curves' caches remain unaffected
- Cache clearing happens on: curve creation, curve modification, curve deletion

**Cache Performance:**
- Subsequent calls to GetCurveIndexValue for same coordinates within 30 minutes return instantly
- No mathematical calculations performed for cached coordinates
- Background caching of surrounding cells (100-cell radius) for performance optimization


## **Error Handling & Response Codes:**

### **Standard Error Response Format:**
```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error description",
    "field": "field_name_where_error_occurred",
    "details": "Additional technical details"
  },
  "timestamp": "ISO-8601 string"
}
```

### **HTTP Status Codes:**
- **200 OK**: Successful operation
- **201 Created**: Curve successfully created
- **400 Bad Request**: Validation errors, malformed data
- **404 Not Found**: Curve not found, invalid ID
- **409 Conflict**: Curve name already exists
- **422 Unprocessable Entity**: Business logic validation failed
- **429 Too Many Requests**: Rate limit exceeded
- **500 Internal Server Error**: Server processing error

### **Specific Error Codes:**

#### **Validation Errors (400):**
- `VALIDATION_ERROR`: General validation failure
- `MISSING_REQUIRED_FIELD`: Required field not provided
- `INVALID_DATA_TYPE`: Wrong data type for field
- `VALUE_OUT_OF_RANGE`: Value exceeds allowed range
- `INVALID_FORMAT`: Data format not acceptable

#### **Business Logic Errors (422):**
- `CURVE_NAME_TAKEN`: Curve name already exists in system
- `INVALID_CURVE_TYPE`: Curve type not in allowed values
- `ARRAY_LENGTH_MISMATCH`: curve-data length ≠ curve-width
- `INVALID_GRID_COORDINATES`: Grid coordinates must satisfy: x2 > x1 AND y2 > y1
- `COORDINATE_OUT_OF_BOUNDS`: Coordinates exceed system limits

#### **Resource Errors (404):**
- `CURVE_NOT_FOUND`: Curve with specified ID/name doesn't exist
- `INVALID_CURVE_ID`: Malformed or invalid curve identifier

#### **System Errors (500):**
- `PROCESSING_ERROR`: Mathematical calculation failure
- `CACHE_ERROR`: Cache operation failure
- `DATABASE_ERROR`: Firestore operation failure

#### **Rate Limiting (429):**
- `RATE_LIMIT_EXCEEDED`: Too many requests, try again later

### **Error Examples:**

#### **Curve Name Already Exists (409):**
```json
{
  "success": false,
  "error": {
    "code": "CURVE_NAME_TAKEN",
    "message": "A curve with name 'mountain-terrain' already exists",
    "field": "curve-name",
    "details": "Choose a different name or use PUT to update existing curve"
  },
  "timestamp": "2025-08-27T04:50:11.827Z"
}
```

#### **Invalid Grid Coordinates (422):** 
```json
{
  "success": false,
  "error": {
    "code": "INVALID_GRID_COORDINATES",
    "message": "Grid coordinates must satisfy: x2 > x1 AND y2 > y1",
    "field": "coordinates",
    "details": "x2 must be > x1 and y2 must be > y1. Received: x1=25, y1=30, x2=10, y2=15"
  },
  "timestamp": "2025-08-27T04:50:11.827Z"
}
```

#### **Validation Error (400):**
```json
{
  "success": false,
  "error": {
    "code": "VALUE_OUT_OF_RANGE",
    "message": "curve-index-scaling must be between 0 and 1.0",
    "field": "curve-index-scaling",
    "details": "Received value: 1.5, allowed range: 0.0 to 1.0"
  },
  "timestamp": "2025-08-27T04:50:11.827Z"
}
```

#### **Rate Limit Exceeded (429):**
```json
{
  "success": false,
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "Too many requests, please try again later",
    "field": "rate_limit",
    "details": "Limit: 100 requests per minute, reset at: 2025-08-27T05:50:11.827Z"
  },
  "timestamp": "2025-08-27T05:45:11.827Z"
}
```

### **Success Response Format:**
```json
{
  "success": true,
  "data": { /* response data */ },
  "message": "Optional success message",
  "timestamp": "ISO-8601 string"
}
```
{
  "success": true,
  "data": {
    "id": "firestore-generated-id",
    "curve-name": "mountain-terrain",
    "curve-description": "Rocky mountain landscape"
  },
  "message": "Curve created successfully",
  "timestamp": "2025-08-27T04:50:11.827Z"
}
```


 
 
Reference Items:


When I refer to cells I mean one integer based coordinate 0,0 0,1 1,0 1,1 would mean 4 cells.
 
// CoordKey.ts
// Utility for generating unique, predictable keys from integer coordinates (x, y)
// Fastest approach: canonical string concatenation with a non-numeric delimiter.
// Only supports safe integers (Number). Throws if not safe.

/////////////////////////////
// Internal helper
/////////////////////////////

/**
 * Convert a Number to a canonical base-10 string.
 * - Must be a safe integer (within ±9,007,199,254,740,991).
 */
function intToCanonicalString(n: number): string {
  if (!Number.isInteger(n)) {
    throw new TypeError("Coordinate must be an integer");
  }
  if (!Number.isSafeInteger(n)) {
    throw new RangeError(
      "Coordinate exceeds safe integer range (±9,007,199,254,740,991)"
    );
  }
  return String(n); // canonical base-10, no leading zeros or sci-notation
}

/////////////////////////////
// Public API
/////////////////////////////

/**
 * Create a unique, predictable key for (x, y).
 * Uses ASCII Unit Separator (0x1F) as a delimiter, which never appears in numeric strings.
 *
 * Example: coordKey(-12, 345) => "-12\x1F345"
 */
export function coordKey(x: number, y: number): string {
  const xs = intToCanonicalString(x);
  const ys = intToCanonicalString(y);
  return xs + "\x1F" + ys;
}

/**
 * Parse a key back into its string components.
 * Caller can convert them to Numbers if needed.
 */
export function parseCoordKey(
  key: string
): { xs: string; ys: string } {
  const i = key.indexOf("\x1F");
  if (i < 0) {
    throw new Error("Invalid CoordKey: missing delimiter");
  }
  const xs = key.slice(0, i);
  const ys = key.slice(i + 1);
  return { xs, ys };
}

/////////////////////////////
// Example usage
/////////////////////////////

if (require.main === module) {
  console.log("Examples:");
  console.log(coordKey(0, 0));               // "0\x1F0"
  console.log(coordKey(-123, 987654321));    // "-123\x1F987654321"

  const k = coordKey(10, -10);
  const { xs, ys } = parseCoordKey(k);
  console.log(k, { xs, ys, asNumbers: [Number(xs), Number(ys)] });

  /////////////////////////////
  // Benchmark
  /////////////////////////////
  const ITER = 1e6;
  console.log(`\nBenchmark: ${ITER.toLocaleString()} keys...`);
  console.time("CoordKey");
  for (let i = 0; i < ITER; i++) {
    coordKey(i, -i);
  }
  console.timeEnd("CoordKey");
}







 
 
 
Appendix Items:
 
The following are for reference only to define things and not to influence coding beyond defining these types of distortions.
 
 ## 2. Angular Distortion

### 2.1 Angular Distortion Concept
- **Angular Distortion**: Applies non-linear transformations to the index based on angular relationships
- **Purpose**: Creates organic, non-uniform terrain patterns that mimic natural geological formations
- **Mathematical Basis**: Uses trigonometric functions to distort the linear index progression

### 2.2 Angular Distortion Effects
```
No Angular Distortion:
- Linear index progression: 0, 1, 2, 3, 4, 5...
- Uniform terrain distribution
- Predictable patterns

With Angular Distortion:
- Non-linear index progression: 0, 1.2, 2.8, 3.1, 4.9, 5.3...
- Organic, irregular terrain distribution
- Natural-looking variations
```

### 2.3 Angular Distortion Implementation
```python
def apply_angular_distortion(index, distortion_strength, curve_width):
    # Convert index to normalized position (0 to 2π)
    angle = (index / curve_width) * 2 * math.pi
    
    # Apply distortion using sine wave modulation
    distortion = math.sin(angle * distortion_strength) * distortion_strength
    
    # Apply the distortion to the index
    distorted_index = index + distortion
    
    # Wrap around and clamp to valid range
    distorted_index = distorted_index % curve_width
    distorted_index = max(0, min(distorted_index, curve_width - 1))
    
    return distorted_index
```

 
 
 ## 3. Index Distortion

### 3.1 Index Distortion Concept
- **Index Distortion**: Applies mathematical transformations to the base index before accessing curve data
- **Purpose**: Creates more complex and interesting terrain patterns by warping the coordinate space
- **Types**: 
  - **Perlin-based distortion**: Uses Perlin noise to create smooth, organic distortions
  - **Fractal distortion**: Combines multiple octaves of distortion for complex patterns
  - **Custom distortion**: User-defined distortion functions

### 3.2 Index Distortion Effects on Positioning
```
Base Index: 100
No Distortion: curve_data[100]

With Perlin Distortion:
- distortion_offset = perlin_noise(100 * 0.01) * 50
- distorted_index = 100 + distortion_offset
- Result: curve_data[distorted_index] where distorted_index varies around 100

With Fractal Distortion:
- distortion_offset = fractal_noise(100 * 0.01, octaves=4) * 100
- distorted_index = 100 + distortion_offset
- Result: curve_data[distorted_index] with complex, multi-scale variations
```

### 3.3 Index Distortion Implementation
```python
def apply_index_distortion(base_index, distortion_type, distortion_params, curve_width):
    if distortion_type == "perlin":
        # Apply Perlin noise-based distortion
        noise_input = base_index * distortion_params.get('scale', 0.01)
        distortion_offset = perlin_noise(noise_input) * distortion_params.get('strength', 50)
        
    elif distortion_type == "fractal":
        # Apply fractal noise-based distortion
        noise_input = base_index * distortion_params.get('scale', 0.01)
        octaves = distortion_params.get('octaves', 4)
        distortion_offset = fractal_noise(noise_input, octaves) * distortion_params.get('strength', 100)
        
    else:
        distortion_offset = 0
    
    # Apply distortion to base index
    distorted_index = base_index + distortion_offset
    
    # Wrap around and clamp to valid range
    distorted_index = distorted_index % curve_width
    distorted_index = max(0, min(distorted_index, curve_width - 1))
    
    return int(distorted_index)
    
    
    
    
    
    
     
 
 
 
 
 
